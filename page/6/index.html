<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>Page 6 | Moodpo Blog</title>
  <meta name="author" content="yangxiaoxie">
  
  <meta name="description" content="moodpo">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

  
  <meta property="og:site_name" content="Moodpo Blog"/>

  <link rel="alternate" href="/atom.xml" title="Moodpo Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-43415414-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <div class="wrapper">
    <header id="header"><div class="title">
  <h1><a href="/">Moodpo Blog</a></h1>
  <p><a href="/">记录生活点滴，感悟程序人生</a></p>
</div>
<nav class="nav">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
    <div class="content">
  <article class="post">
  <header>
    
      <div class="icon"></div>
      <time datetime="2013-03-12T05:56:20.000Z"><a href="/2013/03/12/struts-2-data-transfer-and-type-conversion-mechanism-1/">Mar 12 2013</a></time>
    
    
  
    <h1 class="title"><a href="/2013/03/12/struts-2-data-transfer-and-type-conversion-mechanism-1/">Struts 2 的数据转移和类型转换机制(一)</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>在实际的开发中的大部分情况，Struts2框剪已经非常好的自动完成了数据转移和类型转换任务。然而若想进一步提高我们的能力，花一点时间和精力来学习数据转移和类型转换究竟是如何工作的将是必要的。也许你已经学会了在简单的情况下如何利用自动数据转移，然而在面临更加复杂的Java端类型(例如Map和List)时，将怎样编写代码呢？本节内容正是要解答上述疑问的。</p>
<h3>1.数据转移和类型转换：Web应用程序领域的常见任务</h3>
<p>Web应用程序领域的一个常见任务是从基于字符床的HTTP向Java语言的不同类型移动和转换数据。将字符床解析为double或者float，捕获坏数据抛出的异常，这些任务没有一点意思。更糟的是，这些任务实际上是纯基础设施。</p>
<p>数据转移和类型转换实际上发生在请求处理周期的两端。几乎Web应用程序中的每一个请求都会发生这个过程，它是这个领域与生俱来的部分。大部分时候我们会将这个责任交给框架，然而有些时候我们会想扩展或者配置这个自动化支持。Struts2类型转换机制功能强大并且特别容易扩展。</p>
<h4>1.1 OGNL和Struts2</h4>
<p>我们还没有解释所有这些数据如何从HTTP请求到Java语言，以及如何再通过JSP标签回到HTML。下面的内容将阐明这个神秘的过程。</p>
<h5>1.1.1 OGNL是什么</h5>
<p>OGNL是Object-Graph Navigation Language(对象图导航语言)的简称。这听起来有些让人恐惧，似乎我们在学校里学的还不够，它听起来太学术味了。OGNL是一种强大的技术，它被集成在Struts2框架中用来帮助实现数据转移和类型转换。从开发人员基于Struts2框架构建应用程序的角度看，OGNL包含两件事：表达式语言和类型转换器。</p>
<p><strong>1.表达式语言</strong></p>
<p>我们已经在表单输入字段的name属性和JSP标签中使用过OGNL表达式语言了。这这两个地方，我们使用OGNL表达式将Java端的数据属性和基于文本的视图层中的字符串绑定起来。</p>
<pre><code><figure class="highlight"><pre><span class="tag">&lt;<span class="title">h5</span>&gt;</span>Congratulations! You have created <span class="tag">&lt;/<span class="title">h5</span>&gt;</span>
<span class="tag">&lt;<span class="title">h3</span>&gt;</span>The <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"portfolioName"</span> /&gt;</span> Portfolio<span class="tag">&lt;/<span class="title">h3</span>&gt;</span>
</pre></figure></code></pre>
<p>OGNL表达式语言是value属性双引号之间的片段，Struts2 property标签从对象的属性中取值，然后将它写入到HTML中代替这个标签，这是表达式语言的要点。表达式语言允许我们使用简单的语法来引用Java环境中存在的对象。</p>
<p>注：OGNL转义序列%{表达式}可用来告诉框架什么时候把表达式当成OGNL表达式而不是作为字符串面值解析；在默认情况下，框架敬爱那个自动把字符串当作OGNL表达式求值。</p>
<p><strong>2.类型转换</strong></p>
<p>基于字符串的HTML世界和框架的本地Java类型之间移动数据时类型转换是如何发生的呢？除了表达式语言，我们也一直在使用OGNL类型转换器。数据转移时类型转换必定发生，即使是两端类型(是字符串时)相同，这仅仅意味着类型转换比较容易。</p>
<h6>1.1.2 OGNL如何融入框架</h6>
<p>数据进入和离开框架时，数据在不同的区域间移动时，OGNL如何帮助绑定和转换数据呢？下图展示了整个过程。</p>
<p><img src="http://meiseku.com/moodpo/2013/03/272061022.png" alt="数据转移和类型转换过程.png" title="数据转移和类型转换过程.png"></p>
<p><strong>1.数据进入</strong></p>
<p>用户输入名字和年龄，并提交了表单，数据的旅程就开始了。当数据进入框架后，它作为一个HttpServletRequest对象公开给Java语言。Struts2经请求参数作为名/值对存储，名和值都是String类型。接下来框架开始处理这些参数的数据转移以及类型转换。</p>
<p>如图所示，在开始时，Struts2就会将动作对象置于叫做ValueStack的对象上，而User对象作为动作的组件的JavaBean属性也被公开出来。而另一方面，当用户发出请求时，params拦截器会把请求对象中的数据转移到ValueStack上。于是，用户提交的数据属性和Struts2公开的属性就会在ValueStack上出现重复。此时神奇的事情发生了，接下来就是见证奇迹的时刻：</p>
<p>ValueStack是一个Struts2结构，它呈现了一堆对象属性的聚合。如果有重复属性存在，那么栈中最高的对象的属性会是由ValueStack代表的虚拟对象公开的属性。在上述情况下，由于Struts2公开属性在前，而用户提交数据在后，在栈中用户提交的数据更高，于是数据就自动找到了转移到Struts2公开的对象的属性上的道路。</p>
<p>在使用OGNL表达式定位到目标属性之后，可以通过使用正确的值调用属性的set方法把数据移动到这个属性上。这是类型转换就开始工作了。我们需要把字符串转换为OGNL指向的age属性的Java类型。OGNL会咨询它可用的类型转换器的集合一确定是否他们中某个可以处理这个特定的转换。</p>
<p><strong>2.数据流出</strong></p>
<p>与数据进入相反，在动作完成自身的业务、调用业务逻辑、做数据操作后，某个最终结果会触发，它会向用户呈现一个新的应用程序试图。在这个过程中，数据对象会一直保留在ValueStack上。当结果开始自己的呈现过程时，它也通过标签中的OGNL表达式语言访问ValueStack，从其中取得数据。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>



  <article class="post">
  <header>
    
      <div class="icon"></div>
      <time datetime="2013-03-11T05:54:01.000Z"><a href="/2013/03/11/struts-2-interceptor-2/">Mar 11 2013</a></time>
    
    
  
    <h1 class="title"><a href="/2013/03/11/struts-2-interceptor-2/">Struts 2 拦截器(二)</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><img src="http://meiseku.com/moodpo/2013/03/2759728019.jpg" alt="拦截器.jpg" title="拦截器.jpg"></p>
<h3>1.声明拦截器</h3>
<p>XML是声明拦截器的唯一选择，注解机制现在还不支持声明拦截器。</p>
<h4>1.1 声明独立的拦截器和拦截器栈</h4>
<p>通常，拦截器声明包含声明可用的拦截器并把它们与应该触发的动作关联起来。像所有框架组件的声明一样，拦截器的声明必须在package元素内部。以下是struts-default.xml文件中struts-default包的各个拦截器的声明：</p>
<pre><code><figure class="highlight"><pre><span class="xml"><span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"struts-default"</span> <span class="attribute">abstract</span>=<span class="value">"true"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">interceptors</span>&gt;</span>
         ......
        <span class="tag">&lt;<span class="title">interceptor</span> <span class="attribute">name</span>=<span class="value">"execAndWait"</span> <span class="attribute">class</span>=<span class="value">"org.apache.struts2.interceptor.ExecuteAndWaitInterceptor"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor</span> <span class="attribute">name</span>=<span class="value">"exception"</span> <span class="attribute">class</span>=<span class="value">"com.opensymphony.xwork2.interceptor.ExceptionMappingInterceptor"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor</span> <span class="attribute">name</span>=<span class="value">"fileUpload"</span> <span class="attribute">class</span>=<span class="value">"org.apache.struts2.interceptor.FileUploadInterceptor"</span>/&gt;</span>
         ......

        <span class="tag">&lt;<span class="title">interceptor-stack</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span>
                <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"exception"</span>/&gt;</span>
                <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"alias"</span>/&gt;</span>
                <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"servletConfig"</span>/&gt;</span>
                <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"i18n"</span>/&gt;</span>
                <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"prepare"</span>/&gt;</span>
                <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"chain"</span>/&gt;</span>
                <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"debugging"</span>/&gt;</span>
                <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"scopedModelDriven"</span>/&gt;</span>
                <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"modelDriven"</span>/&gt;</span>
                <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"fileUpload"</span>/&gt;</span>
                <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"checkbox"</span>/&gt;</span>
                <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"multiselect"</span>/&gt;</span>
                <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"staticParams"</span>/&gt;</span>
                <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"actionMappingParams"</span>/&gt;</span>
                <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"params"</span>&gt;</span>
                    <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"excludeParams"</span>&gt;</span>dojo\..*,</span><span class="keyword">^struts</span><span class="xml">\..*<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
                <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
                <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"conversionError"</span>/&gt;</span>
                <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"validation"</span>&gt;</span>
                    <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"excludeMethods"</span>&gt;</span>input,back,cancel,browse<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
                <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
                <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"workflow"</span>&gt;</span>
                    <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"excludeMethods"</span>&gt;</span>input,back,cancel,browse<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
                <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">interceptor-stack</span>&gt;</span>

            <span class="tag">&lt;<span class="title">default-interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>/&gt;</span>
    <span class="tag">&lt;/<span class="title">interceptors</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span></span>
</pre></figure></code></pre>
<p>interceptors元素包含这个包内所有的interceptor和interceptor-stack的声明。每个interceptor元素声明了一个可以在包内使用的拦截器。这些声明实际上没有创建一个拦截器或者把这个拦截器与任何动作关联，它们只是把一个名字映射到一个类。struts-default包声明了几个栈，其中中最重要的是defaultStack。</p>
<p>interceptor-stack元素的内容是一系列interceptor-ref元素，这些引用必须都指向interceptor元素创建的某个逻辑名，interceptor-ref元素也可以传入参数来配置引用创建的拦截器实例。</p>
<p>最后，一个包可以定义一组默认的拦截器，default-interceptor-ref定义的拦截器组会与这个包内没有显示声明自己的拦截器的所有动作关联，它只指向一个逻辑名，这里是defaultStack。</p>
<p><strong>XML文档结构</strong></p>
<p>声明使用的XML文档必须遵守特定的顺序规则，这可以通过DTD查看：</p>
<pre><code><figure class="highlight"><pre>&lt;!ELEMENT struts ((<span class="keyword">package</span>|<span class="keyword">include</span>|bean|constant)*, unknown-handler-stack?)&gt;
&lt;!ELEMENT <span class="package"><span class="keyword">package</span> (<span class="title">result</span>-<span class="title">types</span>?, <span class="title">interceptors</span>?, <span class="title">default</span>-<span class="title">interceptor</span>-<span class="title">ref</span>?, <span class="title">default</span>-<span class="title">action</span>-<span class="title">ref</span>?, <span class="title">default</span>-<span class="title">class</span>-<span class="title">ref</span>?, <span class="title">global</span>-<span class="title">results</span>?, <span class="title">global</span>-<span class="title">exception</span>-<span class="title">mappings</span>?, <span class="title">action</span>*)&gt;
</pre></figure></code></pre>
<p>上述语句指出，struts-default.xml文件以struts元素开始，这个元素能够包含4种不同的元素类型的0个或者多个实例。与struts的元素不同，package元素的内容必须遵照特定的顺序。另外，所有包含在一个package元素中的元素，出action元素外，都只能出现一次。interceptors元素必须只出现一次或者一次也不出现，并且不需出现在result-types元素之后，并且在default-interceptor-ref元素之前。</p>
<h4>1.2 将拦截器映射到动作组件</h4>
<p>可以使用interceptor-ref元素完成拦截器和动作的关联，以下代码片段显示了如何将一系列拦截器和一个特定的动作关联起来：</p>
<pre><code><figure class="highlight"><pre><span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"MyAction"</span> <span class="attribute">class</span>=<span class="value">"com.moodpo.review.MyAction"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"timer"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
    <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"logger"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
    <span class="comment">&lt;!-- 需要再次声明使用defaultStack --&gt;</span>
    <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
    <span class="tag">&lt;<span class="title">result</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
<span class="tag">&lt;/<span class="title">action</span>&gt;</span>
</pre></figure></code></pre>
<p>首先，这个动作命名了拦截器，但没有提及在struts-default包中声明的defaultStack。正因如此，这个动作必须在一个扩展了struts-default的包中。其次，虽然没有定义任何interceptor-ref的动作会继承默认的拦截器，但是只要动作声明了自己的拦截器，它就失去了自己的默认值，并且为了使用defaultStack就必须显式指出。</p>
<h4>1.3 设置、覆盖拦截器参数</h4>
<p>很多拦截器可以被参数化。如果一个拦截器接受参数，那么interceptor-ref元素是向它们传入参数的地方。比如之前所说的workflow拦截器被参数化以忽略对动作的某些方法名的访问：</p>
<pre><code><figure class="highlight"><pre><span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"workflow"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"excludeMethods"</span>&gt;</span>input,back,cancel,browse<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
<span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
</pre></figure></code></pre>
<p>如果我们想重用包含了defaultStack的拦截器栈，但是我们想改变excludeMethods参数的值要怎么办呢？很简单，代码如下：</p>
<pre><code><figure class="highlight"><pre><span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"MyAction"</span> <span class="attribute">class</span>=<span class="value">"com.moodpo.review.MyAction"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"workflow.excludeMethods"</span>&gt;</span>dosomething<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
    <span class="tag">&lt;<span class="title">result</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
<span class="tag">&lt;/<span class="title">action</span>&gt;</span>
</pre></figure></code></pre>
<h3>2.构建自定义拦截器</h3>
<p>除了安排栈的顺序和在调试中学习解决顺序问题需要多加留意外，编写拦截器其实很容易。</p>
<h4>2.1 实现Interceptor接口</h4>
<p>在编写一个拦截器时需要实现com.opensymphony.xwork2.interceptor.Interceptor接口。</p>
<pre><code><figure class="highlight"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> <span class="keyword">extends</span> <span class="title">Serializable</span> {</span>
    <span class="keyword">public</span> <span class="keyword">void</span> destroy();
    <span class="keyword">public</span> <span class="keyword">void</span> init();
    <span class="keyword">public</span> String intercept(ActionInvocation actionInvocation) <span class="keyword">throws</span> Exception;
}
</pre></figure></code></pre>
<p>可以看到，这个简单的接口只定义了3个方法，前两个方法是典型的生命周期方法，真正的业务逻辑发生在intercept()方法中。</p>
<h4>2.2 声明拦截器并构建新的默认栈</h4>
<p>在定义完拦截器类后，需要将这个拦截器应用在动作上，所以可以构建一个自定栈，它的大致写法如下：</p>
<pre><code><figure class="highlight"><pre><span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"demo4Secure"</span> <span class="attribute">namespace</span>=<span class="value">"/secure"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span>

    <span class="tag">&lt;<span class="title">interceptors</span>&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor</span> <span class="attribute">name</span>=<span class="value">"yourInterceptor"</span> <span class="attribute">class</span>=<span class="value">"com.moodpo.review.utils.YourInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor</span>&gt;</span>

        <span class="tag">&lt;<span class="title">interceptor-stack</span> <span class="attribute">name</span>=<span class="value">"myStack"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"yourInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">interceptor-stack</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">interceptors</span>&gt;</span>

    <span class="tag">&lt;<span class="title">default-interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"myStack"</span>&gt;</span><span class="tag">&lt;/<span class="title">default-interceptor-ref</span>&gt;</span>

    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"yourAction"</span> <span class="attribute">class</span>=<span class="value">"com.moodpo.review.action.YourAction"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>

<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></figure></code></pre>
<p>首先，我们必须使用一个interceptors元素来包含所有的interceptor和interceptor-stack的声明。我们必须使用一个interceptor元素将Java类映射到一个逻辑名(yourInterceptor)。其次，我们构建了一个新栈，这个栈使用defaultStack并且把新拦截器追加到它的上面(当然根据业务的不同，也可以放在下面)。最后，我们把myStack声明为这个包的默认拦截器栈。以上这样做的好处是拦截器与动作代码完全分离，并且实现了可重用。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>



  <article class="post">
  <header>
    
      <div class="icon"></div>
      <time datetime="2013-03-10T05:48:55.000Z"><a href="/2013/03/10/struts-2-interceptor-1/">Mar 10 2013</a></time>
    
    
  
    <h1 class="title"><a href="/2013/03/10/struts-2-interceptor-1/">Struts 2 拦截器(一)</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>从开发人员日常工作的角度来看，动作组件可能是框架的核心和灵魂，然而在后台工作的默默无闻的拦截器却可以说是真正的英雄——拦截器负责完成了框架的大部分处理工作。</p>
<h3>1.拦截请求的意义</h3>
<h4>1.1 清理MVC</h4>
<p>拦截器消除了动作组件中的横切任务。日志记录功能是典型的横切任务，它不是某一个动作所特有的，而是横向关联所有动作。作为软件工程师，我们会把这个任务提到更高的层面，让它处在任何需要日志记录的请求上(或者说之前)，达到将MVC关注点分离的目的。</p>
<p>拦截器承担的另一些任务被称为预处理或者后加工。预处理任务的一个很好的示例就是常见的数据转移，它通过params拦截器实现。</p>
<p>在Struts2中没有一个动作被单独调用，动作调用是一个分层的过程，总是包含一系列的拦截器在动作执行之前或者之后执行。框架不直接调用动作的execute()方法，而是创建一个叫做ActionInvocation的对象，它封装了动作的一系列被配置的动作执行之前之后触发的拦截器。下图展示了ActionInvocation类封装的完整的动作执行过程。</p>
<p><img src="http://meiseku.com/moodpo/2013/03/3358556227.png" alt="ActionInvocation 流程.png" title="ActionInvocation 流程.png"></p>
<p>拦截器的强大功能之一是改变调用工作流。有时候某个拦截器会决定动作不应该执行，此时，拦截器可以自己返回一个控制字符串，从而终止工作流。以workflow拦截器为例，这个拦截器做两件事情。首先，如果动作实现了Validateable接口，那么调用动作的validate()方法。其次，检查动作上是否出现了错误信息。如果出现了错误信息，它返回控制字符串并终止后续执行。</p>
<h4>1.2 拦截器的好处</h4>
<p>使用拦截器分层让软件更整洁，并增加了可读性和可测试性，也提高了灵活性。从这种灵活性中得到的两个主要益处是可重用和可配置。</p>
<p>每一个人都想重用软件，想达到可重用很简单，只需将想重用的逻辑隔离到清晰分割的单元。把这些逻辑隔离到拦截器之后，我们可以把它们放在任何地方，应用到所有动作类上。例如我们通常通过继承defaultstack获得的代码重用。</p>
<p>除代码重用之外，拦截器分层的能力还给我们带来了另外一些非常重要的好处。我们能够很容易的配置它们的顺序和数量。</p>
<h3>2.拦截器的工作原理</h3>
<h4>2.1 总指挥 ActionInvocation</h4>
<p>ActionInvocation封装了与特定动作执行相关的所有处理细节，所以知道ActionInvocation做什么就等于知道Struts2如何处理请求。当框架收到一个请求时，它首先必须决定这个URL映射到哪个动作，这个动作的一个实例会被加入到一个新创建的ActionInvocation示例中。接着，框架咨询声明性架构(通过xml或者Java注解)，以发现哪些拦截器应该触发，指向这些拦截器的引用将被加入到ActionInvocation中。</p>
<h4>2.2 如何触发拦截器</h4>
<p>框架创建了ActionInvocation，并填充了需要的所有对象和信息，通过调用ActionInvocation公开的invoke()方法开始动作的执行，此时拦截器栈中的第一个拦截器开始调用过程。ActionInvation负责跟踪执行过程达到的状态，并把控制交给栈中合适的拦截器。ActionInvation通过调用拦截器的intercept()方法将控制转交给拦截器。后续拦截器继续执行，最终执行动作。这些都是通过递归调用ActionInvocation的invoke()方法实现。</p>
<ol>
<li>调用ActionInvocation对象的invoke()方法</li>
<li>开始调用第一个拦截器</li>
<li>调用拦截器的intercept()方法，并把ActionInvocation实例作为参数传递</li>
<li>拦截器调用传递的参数即ActionInvocation实例的invoke()方法</li>
<li>开始调用第二个拦截器
......
N. 栈中没有拦截器开始触发动作</li>
</ol>
<p>在此过程中，ActionInvocation在内部管理处理状态，它总是能知道现在处在栈的哪里。</p>
<p>拦截器有一个三阶段的、有条件的执行周期，如下所述：</p>
<ol>
<li>做一些预处理</li>
<li>通过调用invoke()方法将控制转移给后续的拦截器，最后直到动作；或者通过返回一个控制字符串终端执行</li>
<li>做一些后加工</li>
</ol>
<h3>3.Struts2 内置的拦截器</h3>
<p>Struts2框架自带了一系列功能强大的内置拦截器，它们提供了你想从Web框架得到的大部分功能。除了defaultStack这个拦截器栈，框架还自带了很多拦截器和已经预先配置好的拦截器栈。</p>
<h4>3.1工具拦截器</h4>
<p>这些拦截器提供了辅助开发、调优及解决问题的简单工具。</p>
<h5>3.1.1 timer拦截器</h5>
<p>这个简单的拦截器只记录执行花费的时间，在拦截器栈中的位置决定了它实际测量什么时间。</p>
<h5>3.1.2 logger拦截器</h5>
<p>这个拦截器提供了一个简单的日志记录机制，记录了在预处理事的进入声明以及在后加工时的退出声明。</p>
<h4>3.2 数据转移拦截器</h4>
<h5>3.2.1 params拦截器(defaultStack)</h5>
<p>这个熟悉的拦截器将请求参数转移到通过ValueStack公开的属性(包括ModelDriven动作通过域模型对象提供的属性)上。params拦截器不知道这些数据最终会去哪里，它只是把数据转移到在ValueStack上发现的第一个匹配的属相上。</p>
<p>动作总是在请求处理周期开始时被放到ValueStack上。ModelDriven动作则被modelDriven拦截器放在ValueStack上。</p>
<h5>3.2.2 static-params拦截器(defaultStack)</h5>
<p>这个拦截器也将参数转移到ValueStack公开的属性上，不同的是参数来源于声明性框架(XML)的动作元素中。</p>
<pre><code><figure class="highlight"><pre><span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"Upload"</span> <span class="attribute">class</span>=<span class="value">"com.moodpo.review.action.Upload"</span>&gt;</span>
    <span class="comment">&lt;!-- 上传路径 --&gt;</span>
    <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"storePath"</span>&gt;</span>E:\temp\<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
    <span class="tag">&lt;<span class="title">result</span>&gt;</span>/Uploaded.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"input"</span>&gt;</span>/UploadForm.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
<span class="tag">&lt;/<span class="title">action</span>&gt;</span>
</pre></figure></code></pre>
<p>注意一点，defaultStack中static-params拦截器在params拦截器之前触发，这意味着请求参数会覆盖XML中param元素的值。</p>
<h5>3.2.3 autowiring拦截器</h5>
<p>这个拦截器为使用Spring管理应用程序资源提供了一个集成点。复习Spring的时候再说吧。</p>
<h5>3.2.4 servlet-config拦截器(defaultStack)</h5>
<p>这个拦截器将来源于Servlet API的各种对象注入到动作中，动作只需实现必要的接口即可。以下的接口可以用来取得与Servlet环境相关的不同对象。</p>
<pre><code><figure class="highlight"><pre>ServletContextAware设置ServletContext
ServletRequestAware设置HttpServletRequest
ServletResponseAware设置HttpServletResponse
ParameterAware设置<span class="keyword">Map</span>类型的请求参数
RequestAware设置<span class="keyword">Map</span>类型的请求属性
SessionAware设置<span class="keyword">Map</span>类型的会话属性
ApplicationAware设置<span class="keyword">Map</span>类型的应用程序领域属性
PrincipalAware设置Principal对象(安全相关)
</pre></figure></code></pre>
<p>每一个接口包含一个方法——当前资源的设置方法。最佳实践建议避免使用Servlet API对象，因为他们会将动作代码绑定到Servlet API.</p>
<h5>3.2.5 fileUpload拦截器(defaultStack)</h5>
<p>fileUpload拦截器将文件和元数据从多重请求转换为常规的请求参数，以便能够将它们像普通参数一样设置到动作上。</p>
<h4>3.3 工作流拦截器</h4>
<p>工作流拦截器提供改变请求处理的工作流的机会，这里的工作流是指贯穿拦截器、动作、结果，最后又回到拦截器的处理路径。工作流拦截器检查处理的状态，有条件的干涉、改变正常路径。</p>
<h5>3.3.1 workflow拦截器(defaultStack)</h5>
<p>确实有一个拦截器就叫workflow。它与动作协作，提供数据验证以及验证错误发生时改变后续工作流的功能。workflow拦截器还引入了另一个重要的拦截器概念——使用params调整拦截器的执行。workflow拦截器可以使用以下几个参数：</p>
<pre><code><figure class="highlight"><pre><span class="function"><span class="title">alwaysInvokeValidate</span><span class="params">(true或者false,默认是true，意味着<span class="function_name">validate</span>()方法会被调用)</span>
<span class="title">inputResultName</span><span class="params">(验证失败时选择的结果的名字，默认值是<span class="variable">Action</span>.<span class="variable">INPUT</span>)</span>
<span class="title">excludeMethods</span><span class="params">(workflow拦截器不应执行的方法名，这样可以略过一个特定入口方法的验证检查)</span>
</pre></figure></code></pre>
<p>这些内容在defaultStack中进行了配置，如下来源于struts-default.xml的代码片段：</p>
<pre><code><figure class="highlight"><pre><span class="tag">&lt;/<span class="title">interceptor-stack</span>&gt;</span>
    ......
    <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"workflow"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"excludeMethods"</span>&gt;</span>input,back,cancel,browse<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
<span class="tag">&lt;/<span class="title">interceptor-stack</span>&gt;</span>
</pre></figure></code></pre>
<p>这样配置将排除input,back,cancel,browse方法上的validate()验证。</p>
<h5>3.3.2 validation拦截器(defaultStack)</h5>
<p>validation拦截器是Struts2验证框架的一部分，提供了声明性的方式验证你的数据。不用编写验证代码，验证框架让你使用XML或者Java注解描述数据的验证规则。</p>
<p>注意：validation拦截器在workflow拦截器之前触发。</p>
<h5>3.3.3 prepare拦截器(defaultStack)</h5>
<p>prepare拦截器提供了一种向动作追加额外工作流处理的通用入口点。当prepare拦截器执行时，它在动作上查找prepare()方法(首先查找是否实现了Preparable接口)，它允许执行任何类型的预处理。</p>
<p>prepare拦截器也很灵活，例如它可以在一个动作上为不同的执行方法定义特别的预备方法。以下是预备方法的命名约定：</p>
<pre><code><figure class="highlight"><pre>动作方法名    预处理方法<span class="number">1</span>                  预处理方法<span class="number">2</span> 
<span class="function"><span class="title">input</span><span class="params">()</span>        <span class="title">prepareInput</span><span class="params">()</span>          <span class="title">prepareDoInput</span><span class="params">()</span> 
<span class="title">update</span><span class="params">()</span>     <span class="title">prepareUpdate</span><span class="params">()</span>       <span class="title">prepareDoUpdate</span><span class="params">()</span>
</pre></figure></code></pre>
<h5>3.3.4 modelDriven(defaultStack)</h5>
<p>modelDriven拦截器通过调用getModel()方法改变执行的工作流，并将模型对象放在ValueStack上从请求接受参数。在不使用这个拦截器的情况下，参数会被params拦截器直接转移到动作对象上。</p>
<h4>3.4 其他拦截器</h4>
<h5>3.4.1 exception拦截器(defaultStack)</h5>
<p>exception拦截器在defaultStack中出现在第一位，也应该在任何你创建的自定义栈中出现在第一位。exception拦截器捕获异常，并根据类型将它们映射到用户自定义的错误页面。它的位置在栈的顶端，这样可以保证它能够捕获动作调用所有阶段可能生成的所有异常，而在后加工阶段又会最后一个触发，因此能够捕获所有的异常。当捕获异常时，exception拦截器会创建一个ExceptionHolder对象，并将其放在ValueStack的最顶端，ExceptionHolder是一个异常的包装器，它把跟踪栈和异常作为JavaBean属性公开出来，可以在错误页面中通过标签访问这些属性。</p>
<h5>3.4.2 token拦截器和token-session拦截器</h5>
<p>token和token-session拦截器可以作为避免表单重复提交系统的一部分。token拦截器用来向被拦截器检查的请求传入一个令牌，如果唯一的令牌再次来到拦截器，那么这个请求被视为重复的。</p>
<h5>3.4.3 scoped-modelDriven拦截器(defaultStack)</h5>
<p>这个拦截器为动作的模型对象提供跨请求的向导式的持久性，它增加了modelDriven拦截器的功能，允许你将模型对象存储到绘画作用域中。</p>
<h5>3.4.4 execAndWait拦截器</h5>
<p>当一个请求需要执行很长时间时，最好能给用户一些反馈，execAndWait拦截器可帮助用户避免急躁。</p>
<h4>3.5 内置的拦截器栈</h4>
<p>大部分可能会用到的其他内置拦截器栈都是defaultStack的简化版本，这些较小的栈是为了成为模块化的构建单元，用来构建更大的栈。</p>
<p>一般情况下推荐使用defaultStack，在某些情况下，多余的拦截器并不会那么影响性能，况且混乱的组织拦截器可能会迅速增加调试的复杂度，因此还是使用内置的最容易的途径——defaultStack吧。</p>
<blockquote>
<p>Struts2不仅非常灵活，而且它也代表着更多的开箱即用。</p>
</blockquote>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>



  <article class="post">
  <header>
    
      <div class="icon"></div>
      <time datetime="2013-03-09T05:32:58.000Z"><a href="/2013/03/09/action-of-struts-2/">Mar 9 2013</a></time>
    
    
  
    <h1 class="title"><a href="/2013/03/09/action-of-struts-2/">Action of Struts 2</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>Struts2是一个面向动作的框架，Action是它的核心。</p>
<h3>1.Struts2中Action的作用</h3>
<p>封装业务单元 为数据转移提供场所 为结果选择路由</p>
<h3>2.使用包(package)机制将Action分组</h3>
<p>包是一种逻辑容器，想Java的包一样，它提供了一种基于功能或者领域的共性将action组件分组。包级别上定义的URL可用来映射到动作；此外它还具有继承的特性，你能够继承框架已经定义好的一些组件。 包声明只需设置它的四个属性：</p>
<pre><code><figure class="highlight"><pre>属性          描述
name(必须)    包的名字
namespace    包内所有action的命名空间
extends      被继承的父包
abstract     如果为true,这个包只能用来定义可继承的组件，不能定义动作

<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"chapterThreeSecure"</span> <span class="attribute">namespace</span>=<span class="value">"/chapterThree/secure"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"AdminPortfolio"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">result</span>&gt;</span>/chapterThree/AdminPortfolio.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"AddImage"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">result</span>&gt;</span>/chapterThree/ImageUploadForm.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"RemoveImage"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">result</span>&gt;</span>/chapterThree/ImageRemoved.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></figure></code></pre>
<p>上面的配置展示了包的用法。当一个请求(比如AddImage)到达时，框架会在/chapterThree/secure命名空间下查找AddImage的action方法，如果没有设置命名空间，请求动作就会进入默认命名空间查找。因为继承了struts-default包，而使用其中的默认命名空间。</p>
<p><strong>struts-default包中的组件</strong></p>
<p>只要继承struts-default包，就会自动使用它已经定义好的组件。大部分常用的拦截器在其中已经定义好了，这个包在struts2-core.jar的struts-default.xml中定义，它声明了大多数应用程序用到的拦截器栈：</p>
<pre><code><figure class="highlight"><pre>  &lt;<span class="package"><span class="keyword">package</span> <span class="title">name</span>="<span class="title">struts</span>-<span class="title">default</span>" <span class="title">abstract</span>="<span class="title">true</span>"&gt;
         ........

        &lt;!-- <span class="title">A</span> <span class="title">complete</span> <span class="title">stack</span> <span class="title">with</span> <span class="title">all</span> <span class="title">the</span> <span class="title">common</span> <span class="title">interceptors</span> <span class="title">in</span> <span class="title">place</span>.
             <span class="title">Generally</span>, <span class="title">this</span> <span class="title">stack</span> <span class="title">should</span> <span class="title">be</span> <span class="title">the</span> <span class="title">one</span> <span class="title">you</span> <span class="title">use</span>, <span class="title">though</span> <span class="title">it</span>
             <span class="title">may</span> <span class="title">do</span> <span class="title">more</span> <span class="title">than</span> <span class="title">you</span> <span class="title">need</span>. <span class="title">Also</span>, <span class="title">the</span> <span class="title">ordering</span> <span class="title">can</span> <span class="title">be</span>
             <span class="title">switched</span> <span class="title">around</span> (<span class="title">ex</span>: <span class="title">if</span> <span class="title">you</span> <span class="title">wish</span> <span class="title">to</span> <span class="title">have</span> <span class="title">your</span> <span class="title">servlet</span>-<span class="title">related</span>
             <span class="title">objects</span> <span class="title">applied</span> <span class="title">before</span> <span class="title">prepare</span>() <span class="title">is</span> <span class="title">called</span>, <span class="title">you</span>'<span class="title">d</span> <span class="title">need</span> <span class="title">to</span> <span class="title">move</span>
             <span class="title">servletConfig</span> <span class="title">interceptor</span> <span class="title">up</span>.

             <span class="title">This</span> <span class="title">stack</span> <span class="title">also</span> <span class="title">excludes</span> <span class="title">from</span> <span class="title">the</span> <span class="title">normal</span> <span class="title">validation</span> <span class="title">and</span> <span class="title">workflow</span>
             <span class="title">the</span> <span class="title">method</span> <span class="title">names</span> <span class="title">input</span>, <span class="title">back</span>, <span class="title">and</span> <span class="title">cancel</span>. <span class="title">These</span> <span class="title">typically</span> <span class="title">are</span>
             <span class="title">associated</span> <span class="title">with</span> <span class="title">requests</span> <span class="title">that</span> <span class="title">should</span> <span class="title">not</span> <span class="title">be</span> <span class="title">validated</span>.
             --&gt;
        &lt;<span class="title">interceptor</span>-<span class="title">stack</span> <span class="title">name</span>="<span class="title">defaultStack</span>"&gt;
            &lt;<span class="title">interceptor</span>-<span class="title">ref</span> <span class="title">name</span>="<span class="title">exception</span>"/&gt;
            &lt;<span class="title">interceptor</span>-<span class="title">ref</span> <span class="title">name</span>="<span class="title">alias</span>"/&gt;
            &lt;<span class="title">interceptor</span>-<span class="title">ref</span> <span class="title">name</span>="<span class="title">servletConfig</span>"/&gt;
            &lt;<span class="title">interceptor</span>-<span class="title">ref</span> <span class="title">name</span>="<span class="title">i18n</span>"/&gt;
            &lt;<span class="title">interceptor</span>-<span class="title">ref</span> <span class="title">name</span>="<span class="title">prepare</span>"/&gt;
            &lt;<span class="title">interceptor</span>-<span class="title">ref</span> <span class="title">name</span>="<span class="title">chain</span>"/&gt;
            &lt;<span class="title">interceptor</span>-<span class="title">ref</span> <span class="title">name</span>="<span class="title">debugging</span>"/&gt;
            &lt;<span class="title">interceptor</span>-<span class="title">ref</span> <span class="title">name</span>="<span class="title">scopedModelDriven</span>"/&gt;
            &lt;<span class="title">interceptor</span>-<span class="title">ref</span> <span class="title">name</span>="<span class="title">modelDriven</span>"/&gt;
            &lt;<span class="title">interceptor</span>-<span class="title">ref</span> <span class="title">name</span>="<span class="title">fileUpload</span>"/&gt;
            &lt;<span class="title">interceptor</span>-<span class="title">ref</span> <span class="title">name</span>="<span class="title">checkbox</span>"/&gt;
            &lt;<span class="title">interceptor</span>-<span class="title">ref</span> <span class="title">name</span>="<span class="title">multiselect</span>"/&gt;
            &lt;<span class="title">interceptor</span>-<span class="title">ref</span> <span class="title">name</span>="<span class="title">staticParams</span>"/&gt;
            &lt;<span class="title">interceptor</span>-<span class="title">ref</span> <span class="title">name</span>="<span class="title">actionMappingParams</span>"/&gt;
            &lt;<span class="title">interceptor</span>-<span class="title">ref</span> <span class="title">name</span>="<span class="title">params</span>"&gt;
              &lt;<span class="title">param</span> <span class="title">name</span>="<span class="title">excludeParams</span>"&gt;<span class="title">dojo</span>\..*,^<span class="title">struts</span>\..*&lt;/<span class="title">param</span>&gt;
            &lt;/<span class="title">interceptor</span>-<span class="title">ref</span>&gt;
            &lt;<span class="title">interceptor</span>-<span class="title">ref</span> <span class="title">name</span>="<span class="title">conversionError</span>"/&gt;
            &lt;<span class="title">interceptor</span>-<span class="title">ref</span> <span class="title">name</span>="<span class="title">validation</span>"&gt;
                &lt;<span class="title">param</span> <span class="title">name</span>="<span class="title">excludeMethods</span>"&gt;<span class="title">input</span>,<span class="title">back</span>,<span class="title">cancel</span>,<span class="title">browse</span>&lt;/<span class="title">param</span>&gt;
            &lt;/<span class="title">interceptor</span>-<span class="title">ref</span>&gt;
            &lt;<span class="title">interceptor</span>-<span class="title">ref</span> <span class="title">name</span>="<span class="title">workflow</span>"&gt;
                &lt;<span class="title">param</span> <span class="title">name</span>="<span class="title">excludeMethods</span>"&gt;<span class="title">input</span>,<span class="title">back</span>,<span class="title">cancel</span>,<span class="title">browse</span>&lt;/<span class="title">param</span>&gt;
            &lt;/<span class="title">interceptor</span>-<span class="title">ref</span>&gt;
        &lt;/<span class="title">interceptor</span>-<span class="title">stack</span>&gt;

        ......

   &lt;/<span class="title">interceptors</span>&gt;

    &lt;<span class="title">default</span>-<span class="title">interceptor</span>-<span class="title">ref</span> <span class="title">name</span>="<span class="title">defaultStack</span>"/&gt;

    &lt;<span class="title">default</span>-<span class="title">class</span>-<span class="title">ref</span> <span class="title">class</span>="<span class="title">com</span>.<span class="title">opensymphony</span>.<span class="title">xwork2</span>.<span class="title">ActionSupport</span>" /&gt;
&lt;/<span class="title">package</span>&gt;
</pre></figure></code></pre>
<p>注意那个叫做params的拦截器，从请求到动作的数据自动转移就是由它完成的。</p>
<h3>3.实现动作(Action)</h3>
<p>struts2中的action只需要实现一个返回控制字符串的execute()方法即可，不需要实现action接口，因此基本上任何一个类都可以成为一个动作(action).即使如此框架还是提供了一些接口和实现来让工作变得更简单，成本更小。</p>
<p><strong>Action接口</strong><br>如果一个action实现了com.opensymphony.xwork2.Action接口，它就可以使用一下常量，而这些也正是框架中使用的默认值：</p>
<pre><code><figure class="highlight"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR=<span class="string">"error"</span>;
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INPUT=<span class="string">"input"</span>;
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGIN=<span class="string">"login"</span>;
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NONE=<span class="string">"none"</span>;
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUCCESS=<span class="string">"success"</span>;
</pre></figure></code></pre>
<p><strong>ActionSupport类</strong><br>此类提供了数据验证、错误信息传输及错误信息国际化等功能。</p>
<p><strong>Ⅰ.基本验证</strong></p>
<p>ActionSupport类使用两个接口与默认拦截器栈的DefaultWorkflowInterceptor拦截器配合完成基本验证。</p>
<pre><code><figure class="highlight"><pre>        <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"workflow"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"excludeMethods"</span>&gt;</span>input,back,cancel,browse<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
</pre></figure></code></pre>
<p>当workflow拦截器被触发时，它会在action中查找并执行validate()方法，ActionSupport实现了该方法，不过在实际项目中我们一般要使用自己的业务验证逻辑重写此方法。</p>
<pre><code><figure class="highlight"><pre><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> validate() {
    <span class="comment">// TODO Auto-generated method stub</span>

    <span class="comment">//添加一个字段的数据错误</span>
    addFieldError(<span class="string">"fieldName"</span>, <span class="string">"errorMessage"</span>);
    <span class="comment">//使用国际化</span>
    addFieldError(<span class="string">"name"</span>, getText(<span class="string">"properties_name"</span>));
    <span class="comment">//添加一个action范围内的错误</span>
    addActionError(<span class="string">"anErrorMessage"</span>);

}
</pre></figure></code></pre>
<p>当执行完validate()方法后，workflow拦截器会检查是否有错误信息。如果有错误信息，它将改变请求的工作流，它会立即停止请求的处理，将用户带回到表单页面并显示相应的错误提示。</p>
<p><strong>Ⅱ.使用资源包(国际化)</strong></p>
<p>ActionSupport实现了两个接口，它们协作完成了国际化文本信息的功能。首先是实现com.opensymphony.xwork2.TextProvider接口，可以从资源属性文件中通过关键字获取文本的本地化信息。下面是regist_en.properties文件的内容：</p>
<pre><code><figure class="highlight"><pre><span class="transposed_variable">user.</span>exists=This user already <span class="transposed_variable">exists.</span>
<span class="transposed_variable">username.</span>required=Username is <span class="transposed_variable">required.</span>
<span class="transposed_variable">password.</span>required=Password is <span class="transposed_variable">required.</span>
<span class="transposed_variable">portfolioName.</span>required=Portfolio Name is <span class="transposed_variable">required.</span>
</pre></figure></code></pre>
<p>属性文件创建之后，在action中使用getText(&quot;property_name&quot;)方法即可引用资源属性文件中的本地化信息。</p>
<p>其次，ActionSupport实现了com.opensymphony.xwork2.LocaleProvider接口，它只提供了一个方法getLocale(),可通过浏览器发送来的地域语言信息获取用户所在的地域，从而判断使用那一种资源属性文件来国际化。</p>
<h3>4.action传递域对象数据</h3>
<p>action把请求中的数据放在简单的JavaBean对象上，这种做法很好很强大，但是当JavaBean对象足够复杂之后(如具有很多属性)，这种做法就不够强大了。既然框架提供了数据转移的机制，我们何不直接使用域对象进行数据转移呢？是的，框架允许我们这么做。</p>
<p>有两种实现方式可以做的这一点：</p>
<p>使用JavaBean对象，让数据直接传输到这个对象上 使用模型驱动(ModelDriven)的action</p>
<p><strong>Ⅰ.使用JavaBean方式</strong></p>
<pre><code><figure class="highlight"><pre><span class="keyword">public</span> String execute(){
    getPortfolioService()<span class="variable">.createAccount</span>( user ); 
    <span class="keyword">return</span> SUCCESS;
}

<span class="keyword">private</span> User user; 

<span class="keyword">public</span> User getUser() {
    <span class="keyword">return</span> user;
}

<span class="keyword">public</span> <span class="keyword">void</span> setUser(User user) {
    <span class="keyword">this</span><span class="variable">.user</span> = user;
}

<span class="keyword">public</span> <span class="keyword">void</span> validate(){

    <span class="keyword">if</span> ( getUser()<span class="variable">.getPassword</span>()<span class="variable">.length</span>() == <span class="number">0</span> ){           
        addFieldError( <span class="string">"user.password"</span>, getText(<span class="string">"password.required"</span>) );
    }
    <span class="keyword">if</span> ( getUser()<span class="variable">.getUsername</span>()<span class="variable">.length</span>() == <span class="number">0</span> ){           
        addFieldError( <span class="string">"user.username"</span>, getText(<span class="string">"username.required"</span>) );
    }
            ....
}
</pre></figure></code></pre>
<p>后台代码变的简单了，前台代码就变复杂点了，就是这样无奈。</p>
<pre><code><figure class="highlight"><pre><span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">name</span>=<span class="value">"user.name"</span> <span class="attribute">label</span>=<span class="value">"姓名"</span>/&gt;</span>
</pre></figure></code></pre>
<p><strong>Ⅱ使用模型驱动(ModelDriven)</strong></p>
<p>使用ModelDriven与使用JavaBean方法不同，它使用getModel()方法将域对象公开。它引入了新的接口和拦截器，但拦截器已经包含在默认拦截器栈中了，我们只需要实现getModel()方法即可。</p>
<pre><code><figure class="highlight"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelDrivenRegister</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">ModelDriven</span> {</span>

    <span class="keyword">public</span> String execute(){<span class="comment">//注意在execute方法中只能使用user本来的引用，而不能做任何将其</span>
                                    <span class="comment">//改变引用的操作</span>
        getPortfolioService().createAccount( user ); 
        <span class="keyword">return</span> SUCCESS;
    }

    <span class="keyword">private</span> User user = <span class="keyword">new</span> User();<span class="comment">//注意使用模型驱动需要初始化模型对象</span>

    <span class="keyword">public</span> Object getModel() {
        <span class="keyword">return</span> user;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> validate(){
        PortfolioService ps = getPortfolioService();

        <span class="keyword">if</span> ( user.getPassword().length() == <span class="number">0</span> ){            
            addFieldError( <span class="string">"password"</span>, getText(<span class="string">"password.required"</span>) );
        }
        ......
    }

    <span class="keyword">public</span> PortfolioService getPortfolioService( )  {
        <span class="keyword">return</span> <span class="keyword">new</span> PortfolioService();
    }
}
</pre></figure></code></pre>
<p>值得庆幸的是使用模型驱动的方式传递数据在视图层不需要做任何改变，这也许就是为什么一般选择使用模型驱动而不选择JavaBean方式的原因了。</p>
<p><strong>Ⅲ.使用域对象传递数据的潜在危险</strong></p>
<p>像上面那样使用域对象传递数据的做法很好，但是这样做的前提是要将域对象公开出去，无论是使用JavaBean方式还是模型驱动方式都是如此。但是无论如何将域对象整个的暴露给用户总不是一个很好的做法，它还存在一些潜在的威胁。比如说域对象中有一些敏感的数据你不想公开给外界；一个恶意的用户在请求中添加一个适当命名精心设计的查询语句，这样这个参数就会被自动写入到域对象的属性上。当然你可以进行适当的过滤，但是这样一来使用域对象的目的就变的无效了。这个问题现在也没有很好的解决方法，看的人自己想想，在实际的开发中记住这一点就行。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>



  <article class="post">
  <header>
    
      <div class="icon"></div>
      <time datetime="2013-03-09T05:22:36.000Z"><a href="/2013/03/09/hello-struts-2/">Mar 9 2013</a></time>
    
    
  
    <h1 class="title"><a href="/2013/03/09/hello-struts-2/">Hello Struts 2</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>本文主要复习Struts2的两种声明性架构：</p>
<ul>
<li>基于xml的声明性架构； </li>
<li>基于java注解的声明性架构.</li>
</ul>
<p>需要的jar包：</p>
<ul>
<li>commons-fileupload-1.2.1.jar</li>
<li>commons-io-1.3.2.jar</li>
<li>commons-logging-1.0.4.jar</li>
<li>commons-logging-api-1.1.jar</li>
<li>freemarker-2.3.16.jar </li>
<li>javassist-3.7.ga.jar</li>
<li>ognl-3.0.jar</li>
<li>struts2-core-2.2.1.1.jar</li>
<li>xwork-core-2.2.1.1.jar</li>
</ul>
<h3>1.基于xml的声明性架构</h3>
<p>web.xml配置：</p>
<pre><code><figure class="highlight"><pre><span class="tag">&lt;<span class="title">filter</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter</span>&gt;</span>

<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span>
</pre></figure></code></pre>
<p>struts.xml配置：</p>
<pre><code><figure class="highlight"><pre><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="doctype">&lt;!DOCTYPE struts PUBLIC
    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"
    "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;</span>
<span class="tag">&lt;<span class="title">struts</span>&gt;</span>
    <span class="comment">&lt;!-- 运行于开发者模式 --&gt;</span>
    <span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.devMode"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
    <span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"struts2demo1"</span> <span class="attribute">namespace</span>=<span class="value">"/demo1"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"Name"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">result</span>&gt;</span>/nameCollection.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"Hello"</span> <span class="attribute">class</span>=<span class="value">"xiaoxie.review.struts2demo.HelloworldAction"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"SUCCESS"</span>&gt;</span>/helloworld.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">package</span>&gt;</span>
<span class="tag">&lt;/<span class="title">struts</span>&gt;</span>
</pre></figure></code></pre>
<p>这个示例中包含了两个动作(action),其中一个几乎什么都没做。package元素是一个重要的容器元素，示例中它声明了一个当框架将url映射到动作时需要使用的命名空间：</p>
<pre><code><figure class="highlight"><pre><span class="method">http:</span>//+<span class="method">localhost:</span><span class="number">8080</span>/+struts2demo/+demo1/+helloworld.action
协议+主机名：端口+servlet上下文+命名空间+动作
</pre></figure></code></pre>
<p>nameCollection.jsp</p>
<pre><code><figure class="highlight"><pre>&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span>
    pageEncoding=<span class="string">"UTF-8"</span>%&gt;
<span class="xml"><span class="vbscript">&lt;%@ taglib prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span> %&gt;</span>
<span class="doctype">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Content-Type"</span> <span class="attribute">content</span>=<span class="value">"text/html; charset=UTF-8"</span>&gt;</span>
<span class="tag">&lt;<span class="title">title</span>&gt;</span>Name Collection<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">center</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span>&gt;</span>
            <span class="tag">&lt;<span class="title">h4</span>&gt;</span>输入姓名<span class="tag">&lt;/<span class="title">h4</span>&gt;</span>
            <span class="tag">&lt;<span class="title">s:form</span> <span class="attribute">action</span>=<span class="value">"Hello"</span>&gt;</span>
                <span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">label</span>=<span class="value">"姓名"</span>/&gt;</span>
                <span class="tag">&lt;<span class="title">s:submit</span> <span class="attribute">value</span>=<span class="value">"Submit"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:submit</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">s:form</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">center</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span></span>
</pre></figure></code></pre>
<p>helloworld.jsp</p>
<pre><code><figure class="highlight"><pre>&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span>
    pageEncoding=<span class="string">"UTF-8"</span>%&gt;
<span class="xml"><span class="vbscript">&lt;%@ taglib prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span> %&gt;</span>
<span class="doctype">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Content-Type"</span> <span class="attribute">content</span>=<span class="value">"text/html; charset=UTF-8"</span>&gt;</span>
<span class="tag">&lt;<span class="title">title</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">center</span>&gt;</span>
        <span class="tag">&lt;<span class="title">h4</span>&gt;</span>Hello<span class="tag">&lt;/<span class="title">h4</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"coutomeName"</span>/&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">center</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span></span>
</pre></figure></code></pre>
<p>HelloworldAction.java</p>
<pre><code><figure class="highlight"><pre><span class="package"><span class="keyword">package</span> <span class="title">xiaoxie</span>.<span class="title">review</span>.<span class="title">struts2demo</span>;

<span class="title">public</span> <span class="title">class</span> <span class="title">HelloworldAction</span> {</span>
    <span class="keyword">private</span> String name;
    <span class="keyword">private</span> String coutomeName;
    <span class="keyword">public</span> String getName() {
        <span class="keyword">return</span> name;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> setName(String name) {
        <span class="keyword">this</span>.name = name;
    }

    <span class="keyword">public</span> String getCoutomeName() {
        <span class="keyword">return</span> coutomeName;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> setCoutomeName(String coutomeName) {
        <span class="keyword">this</span>.coutomeName = coutomeName;
    }
    <span class="keyword">public</span> String execute(){
        setCoutomeName(<span class="string">"Hello "</span>+getName());
        <span class="keyword">return</span> <span class="string">"SUCCESS"</span>;
    }
}
</pre></figure></code></pre>
<p>使用JavaBean的方式编写action使领域数据总是存储在action中,action的execute方法可以很方便的访问到数据；而为了在其他地方(比如jsp)也能访问到数据，框架底层也把数据放到了ValueStack中。ValueStack的机制是将action中的所有属性作为它的第一级属性公开出来，这样就可以使用ONGL来访问(<code><s:property value="coutomeName"/></code>).</p>
<h3>2.基于java注解的声明性架构</h3>
<p>在web.xml中添加以下代码</p>
<pre><code><figure class="highlight"><pre><span class="tag">&lt;<span class="title">filter</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span>
    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span>
        <span class="comment">&lt;!-- 扫描xiaoxie包，查找注解 --&gt;</span>
        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>actionPackages<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>
        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>xiaoxie<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter</span>&gt;</span>
</pre></figure></code></pre>
<p>标记哪个类是action类有两种方法：</p>
<ul>
<li>让action类实现com.opensymphony.xwork2.Action接口</li>
<li>使用命名约定，类名以Action结尾 </li>
</ul>
<p>例如：</p>
<pre><code><figure class="highlight"><pre><span class="comment">@Result(name="SUCCESS"</span>,<span class="comment">location="/helloworld</span>.<span class="comment">jsp")</span>  
<span class="comment">public</span> <span class="comment">class</span> <span class="comment">HelloworldAction{</span> <span class="string">.</span><span class="string">.</span><span class="string">.</span><span class="string">.</span><span class="string">.</span><span class="string">.</span> <span class="comment">}
</pre></figure></code></pre>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>




<nav id="pagination">
  
    <a href="/page/5/" class="prev">Prev</a>
  
  
    <a href="/page/7/" class="next">Next</a>
  
  <div class="clearfix"></div>
</nav></div>
  </div>
  <div class="widget-wrapper">
    <aside id="sidebar">
  
  
</aside>
<div class="clearfix"></div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2013 <a href="/">yangxiaoxie</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
  var duoshuoQuery = { short_name: 'moodpo' };
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';
    ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>